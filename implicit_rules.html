

<!DOCTYPE html>
<html class="writer-html5" lang="zh-CN" data-content_root="./">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>隐含规则 &mdash; 跟我一起写Makefile 1.0 文档</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=fa44fd50" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css?v=e59714d7" />

  
      <script src="_static/documentation_options.js?v=f115507d"></script>
      <script src="_static/doctools.js?v=9a2dae69"></script>
      <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
      <script src="_static/translations.js?v=beaddf03"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="索引" href="genindex.html" />
    <link rel="search" title="搜索" href="search.html" />
    <link rel="next" title="使用make更新函数库文件" href="archives.html" />
    <link rel="prev" title="make 的运行" href="invoke.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            跟我一起写Makefile
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">目录</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="overview.html">概述</a></li>
<li class="toctree-l1"><a class="reference internal" href="introduction.html">makefile介绍</a></li>
<li class="toctree-l1"><a class="reference internal" href="rules.html">书写规则</a></li>
<li class="toctree-l1"><a class="reference internal" href="recipes.html">书写命令</a></li>
<li class="toctree-l1"><a class="reference internal" href="variables.html">使用变量</a></li>
<li class="toctree-l1"><a class="reference internal" href="conditionals.html">使用条件判断</a></li>
<li class="toctree-l1"><a class="reference internal" href="functions.html">使用函数</a></li>
<li class="toctree-l1"><a class="reference internal" href="invoke.html">make 的运行</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">隐含规则</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id2">使用隐含规则</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id3">隐含规则一览</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id4">隐含规则使用的变量</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id5">关于命令的变量。</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id6">关于命令参数的变量</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id7">隐含规则链</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id8">定义模式规则</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id9">模式规则介绍</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id10">模式规则示例</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id11">自动化变量</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id12">模式的匹配</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id13">重载内建隐含规则</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id14">老式风格的“后缀规则”</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id15">隐含规则搜索算法</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="archives.html">使用make更新函数库文件</a></li>
<li class="toctree-l1"><a class="reference internal" href="postscript.html">后序</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">跟我一起写Makefile</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">隐含规则</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/implicit_rules.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="id1">
<h1>隐含规则<a class="headerlink" href="#id1" title="Link to this heading">¶</a></h1>
<p>在我们使用Makefile时，有一些我们会经常使用，而且使用频率非常高的东西，比如，我们编译C/C++的源程序为中间目标文件（Unix下是 <code class="docutils literal notranslate"><span class="pre">.o</span></code> 文件，Windows下是 <code class="docutils literal notranslate"><span class="pre">.obj</span></code> 文件）。本章讲述的就是一些在Makefile中的“隐含的”，早先约定了的，不需要我们再写出来的规则。</p>
<p>“隐含规则”也就是一种惯例，make会按照这种“惯例”心照不宣地来运行，那怕我们的Makefile中没有书写这样的规则。例如，把 <code class="docutils literal notranslate"><span class="pre">.c</span></code> 文件编译成 <code class="docutils literal notranslate"><span class="pre">.o</span></code> 文件这一规则，你根本就不用写出来，make会自动推导出这种规则，并生成我们需要的 <code class="docutils literal notranslate"><span class="pre">.o</span></code> 文件。</p>
<p>“隐含规则”会使用一些我们系统变量，我们可以改变这些系统变量的值来定制隐含规则的运行时的参数。如系统变量 <code class="docutils literal notranslate"><span class="pre">CFLAGS</span></code> 可以控制编译时的编译器参数。</p>
<p>我们还可以通过“模式规则”的方式写下自己的隐含规则。用“后缀规则”来定义隐含规则会有许多的限制。使用“模式规则”会显得更智能和清楚，但“后缀规则”可以用来保证我们Makefile的兼容性。我们了解了“隐含规则”，可以让其为我们更好的服务，也会让我们知道一些“约定俗成”了的东西，而不至于使得我们在运行Makefile时出现一些我们觉得莫名其妙的东西。当然，任何事物都是矛盾的，水能载舟，亦可覆舟，所以，有时候“隐含规则”也会给我们造成不小的麻烦。只有了解了它，我们才能更好地使用它。</p>
<section id="id2">
<h2>使用隐含规则<a class="headerlink" href="#id2" title="Link to this heading">¶</a></h2>
<p>如果要使用隐含规则生成你需要的目标，你所需要做的就是不要写出这个目标的规则。那么，make会试图去自动推导产生这个目标的规则和命令，如果 make可以自动推导生成这个目标的规则和命令，那么这个行为就是隐含规则的自动推导。当然，隐含规则是make事先约定好的一些东西。例如，我们有下面的一个Makefile：</p>
<div class="highlight-makefile notranslate"><div class="highlight"><pre><span></span><span class="nf">foo </span><span class="o">:</span><span class="w"> </span><span class="n">foo</span>.<span class="n">o</span> <span class="n">bar</span>.<span class="n">o</span>
<span class="w">    </span>cc<span class="w"> </span>–o<span class="w"> </span>foo<span class="w"> </span>foo.o<span class="w"> </span>bar.o<span class="w"> </span><span class="k">$(</span>CFLAGS<span class="k">)</span><span class="w"> </span><span class="k">$(</span>LDFLAGS<span class="k">)</span>
</pre></div>
</div>
<p>我们可以注意到，这个Makefile中并没有写下如何生成 <code class="docutils literal notranslate"><span class="pre">foo.o</span></code> 和 <code class="docutils literal notranslate"><span class="pre">bar.o</span></code> 这两目标的规则和命令。因为make的“隐含规则”功能会自动为我们自动去推导这两个目标的依赖目标和生成命令。</p>
<p>make会在自己的“隐含规则”库中寻找可以用的规则，如果找到，那么就会使用。如果找不到，那么就会报错。在上面的那个例子中，make调用的隐含规则是，把 <code class="docutils literal notranslate"><span class="pre">.o</span></code> 的目标的依赖文件置成 <code class="docutils literal notranslate"><span class="pre">.c</span></code> ，并使用C的编译命令 <code class="docutils literal notranslate"><span class="pre">cc</span> <span class="pre">–c</span> <span class="pre">$(CFLAGS)</span>&#160; <span class="pre">foo.c</span></code> 来生成 <code class="docutils literal notranslate"><span class="pre">foo.o</span></code> 的目标。也就是说，我们完全没有必要写下下面的两条规则：</p>
<div class="highlight-makefile notranslate"><div class="highlight"><pre><span></span><span class="nf">foo.o </span><span class="o">:</span><span class="w"> </span><span class="n">foo</span>.<span class="n">c</span>
<span class="w">    </span>cc<span class="w"> </span>–c<span class="w"> </span>foo.c<span class="w"> </span><span class="k">$(</span>CFLAGS<span class="k">)</span>
<span class="nf">bar.o </span><span class="o">:</span><span class="w"> </span><span class="n">bar</span>.<span class="n">c</span>
<span class="w">    </span>cc<span class="w"> </span>–c<span class="w"> </span>bar.c<span class="w"> </span><span class="k">$(</span>CFLAGS<span class="k">)</span>
</pre></div>
</div>
<p>因为，这已经是“约定”好了的事了，make和我们约定好了用C编译器 <code class="docutils literal notranslate"><span class="pre">cc</span></code> 生成 <code class="docutils literal notranslate"><span class="pre">.o</span></code> 文件的规则，这就是隐含规则。</p>
<p>当然，如果我们为 <code class="docutils literal notranslate"><span class="pre">.o</span></code> 文件书写了自己的规则，那么make就不会自动推导并调用隐含规则，它会按照我们写好的规则忠实地执行。</p>
<p>还有，在make的“隐含规则库”中，每一条隐含规则都在库中有其顺序，越靠前的则是越被经常使用的，所以，这会导致我们有些时候即使我们显示地指定了目标依赖，make也不会管。如下面这条规则（没有命令）：</p>
<div class="highlight-makefile notranslate"><div class="highlight"><pre><span></span><span class="nf">foo.o </span><span class="o">:</span><span class="w"> </span><span class="n">foo</span>.<span class="n">p</span>
</pre></div>
</div>
<p>依赖文件 <code class="docutils literal notranslate"><span class="pre">foo.p</span></code> （Pascal程序的源文件）有可能变得没有意义。如果目录下存在了 <code class="docutils literal notranslate"><span class="pre">foo.c</span></code> 文件，那么我们的隐含规则一样会生效，并会通过 <code class="docutils literal notranslate"><span class="pre">foo.c</span></code> 调用C的编译器生成 <code class="docutils literal notranslate"><span class="pre">foo.o</span></code> 文件。因为，在隐含规则中，Pascal的规则出现在C的规则之后，所以，make找到可以生成 <code class="docutils literal notranslate"><span class="pre">foo.o</span></code> 的C的规则就不再寻找下一条规则了。如果你确实不希望任何隐含规则推导，那么，你就不要只写出“依赖规则”，而不写命令。</p>
</section>
<section id="id3">
<h2>隐含规则一览<a class="headerlink" href="#id3" title="Link to this heading">¶</a></h2>
<p>这里我们将讲述所有预先设置（也就是make内建）的隐含规则，如果我们不明确地写下规则，那么，make就会在这些规则中寻找所需要规则和命令。当然，我们也可以使用make的参数 <code class="docutils literal notranslate"><span class="pre">-r</span></code> 或 <code class="docutils literal notranslate"><span class="pre">--no-builtin-rules</span></code>
选项来取消所有的预设置的隐含规则。</p>
<p>当然，即使是我们指定了 <code class="docutils literal notranslate"><span class="pre">-r</span></code> 参数，某些隐含规则还是会生效，因为有许多的隐含规则都是使用了“后缀规则”来定义的，所以，只要隐含规则中有 “后缀列表”（也就一系统定义在目标 <code class="docutils literal notranslate"><span class="pre">.SUFFIXES</span></code>
的依赖目标），那么隐含规则就会生效。默认的后缀列表是：.out, .a, .ln, .o,  .c, .cc, .C, .p, .f, .F, .r, .y, .l, .s, .S, .mod, .sym,
.def, .h, .info,  .dvi, .tex, .texinfo, .texi, .txinfo, .w, .ch .web, .sh, .elc, .el。具体的细节，我们会在后面讲述。</p>
<p>还是先来看一看常用的隐含规则吧。</p>
<ol class="arabic">
<li><p>编译C程序的隐含规则。</p>
<p><code class="docutils literal notranslate"><span class="pre">&lt;n&gt;.o</span></code> 的目标的依赖目标会自动推导为 <code class="docutils literal notranslate"><span class="pre">&lt;n&gt;.c</span></code> ，并且其生成命令是 <code class="docutils literal notranslate"><span class="pre">$(CC)</span> <span class="pre">–c</span> <span class="pre">$(CPPFLAGS)</span> <span class="pre">$(CFLAGS)</span></code></p>
</li>
<li><p>编译C++程序的隐含规则。</p>
<p><code class="docutils literal notranslate"><span class="pre">&lt;n&gt;.o</span></code> 的目标的依赖目标会自动推导为 <code class="docutils literal notranslate"><span class="pre">&lt;n&gt;.cc</span></code> 或 <code class="docutils literal notranslate"><span class="pre">&lt;n&gt;.cpp</span></code> 或是 <code class="docutils literal notranslate"><span class="pre">&lt;n&gt;.C</span></code> ，并且其生成命令是
<code class="docutils literal notranslate"><span class="pre">$(CXX)</span> <span class="pre">–c</span> <span class="pre">$(CPPFLAGS)</span> <span class="pre">$(CXXFLAGS)</span></code> 。（建议使用 <code class="docutils literal notranslate"><span class="pre">.cc</span></code> 或 <code class="docutils literal notranslate"><span class="pre">.cpp</span></code> 作为C++源文件的后缀，而不是 <code class="docutils literal notranslate"><span class="pre">.C</span></code> ）</p>
</li>
<li><p>编译Pascal程序的隐含规则。</p>
<p><code class="docutils literal notranslate"><span class="pre">&lt;n&gt;.o</span></code> 的目标的依赖目标会自动推导为 <code class="docutils literal notranslate"><span class="pre">&lt;n&gt;.p</span></code> ，并且其生成命令是 <code class="docutils literal notranslate"><span class="pre">$(PC)</span> <span class="pre">–c</span>&#160; <span class="pre">$(PFLAGS)</span></code> 。</p>
</li>
<li><p>编译Fortran/Ratfor程序的隐含规则。</p>
<p><code class="docutils literal notranslate"><span class="pre">&lt;n&gt;.o</span></code> 的目标的依赖目标会自动推导为 <code class="docutils literal notranslate"><span class="pre">&lt;n&gt;.r</span></code> 或 <code class="docutils literal notranslate"><span class="pre">&lt;n&gt;.F</span></code> 或 <code class="docutils literal notranslate"><span class="pre">&lt;n&gt;.f</span></code> ，并且其生成命令是:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">.f</span></code>  <code class="docutils literal notranslate"><span class="pre">$(FC)</span> <span class="pre">–c</span>&#160; <span class="pre">$(FFLAGS)</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">.F</span></code>  <code class="docutils literal notranslate"><span class="pre">$(FC)</span> <span class="pre">–c</span>&#160; <span class="pre">$(FFLAGS)</span> <span class="pre">$(CPPFLAGS)</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">.r</span></code>  <code class="docutils literal notranslate"><span class="pre">$(FC)</span> <span class="pre">–c</span>&#160; <span class="pre">$(FFLAGS)</span> <span class="pre">$(RFLAGS)</span></code></p></li>
</ul>
</li>
<li><p>预处理Fortran/Ratfor程序的隐含规则。</p>
<p><code class="docutils literal notranslate"><span class="pre">&lt;n&gt;.f</span></code> 的目标的依赖目标会自动推导为 <code class="docutils literal notranslate"><span class="pre">&lt;n&gt;.r</span></code> 或 <code class="docutils literal notranslate"><span class="pre">&lt;n&gt;.F</span></code> 。这个规则只是转换Ratfor
或有预处理的Fortran程序到一个标准的Fortran程序。其使用的命令是：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">.F</span></code>  <code class="docutils literal notranslate"><span class="pre">$(FC)</span> <span class="pre">–F</span> <span class="pre">$(CPPFLAGS)</span> <span class="pre">$(FFLAGS)</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">.r</span></code>  <code class="docutils literal notranslate"><span class="pre">$(FC)</span> <span class="pre">–F</span> <span class="pre">$(FFLAGS)</span> <span class="pre">$(RFLAGS)</span></code></p></li>
</ul>
</li>
<li><p>编译Modula-2程序的隐含规则。</p>
<p><code class="docutils literal notranslate"><span class="pre">&lt;n&gt;.sym</span></code> 的目标的依赖目标会自动推导为 <code class="docutils literal notranslate"><span class="pre">&lt;n&gt;.def</span></code> ，并且其生成命令是：
<code class="docutils literal notranslate"><span class="pre">$(M2C)</span> <span class="pre">$(M2FLAGS)</span> <span class="pre">$(DEFFLAGS)</span></code> 。 <code class="docutils literal notranslate"><span class="pre">&lt;n&gt;.o</span></code> 的目标的依赖目标会自动推导为 <code class="docutils literal notranslate"><span class="pre">&lt;n&gt;.mod</span></code> ，并且其生成命令是： <code class="docutils literal notranslate"><span class="pre">$(M2C)</span> <span class="pre">$(M2FLAGS)</span> <span class="pre">$(MODFLAGS)</span></code> 。</p>
</li>
<li><p>汇编和汇编预处理的隐含规则。</p>
<p><code class="docutils literal notranslate"><span class="pre">&lt;n&gt;.o</span></code> 的目标的依赖目标会自动推导为 <code class="docutils literal notranslate"><span class="pre">&lt;n&gt;.s</span></code> ，默认使用编译器 <code class="docutils literal notranslate"><span class="pre">as</span></code> ，并且其生成命令是： <code class="docutils literal notranslate"><span class="pre">$</span> <span class="pre">(AS)</span> <span class="pre">$(ASFLAGS)</span></code> 。 <code class="docutils literal notranslate"><span class="pre">&lt;n&gt;.s</span></code> 的目标的依赖目标会自动推导为 <code class="docutils literal notranslate"><span class="pre">&lt;n&gt;.S</span></code> ，默认使用C预编译器 <code class="docutils literal notranslate"><span class="pre">cpp</span></code> ，并且其生成命令是： <code class="docutils literal notranslate"><span class="pre">$(CPP)</span> <span class="pre">$(CPPFLAGS)</span></code> 。</p>
</li>
<li><p>链接Object文件的隐含规则。</p>
<p><code class="docutils literal notranslate"><span class="pre">&lt;n&gt;</span></code> 目标依赖于 <code class="docutils literal notranslate"><span class="pre">&lt;n&gt;.o</span></code> ，通过运行C的编译器来运行链接程序生成（一般是 <code class="docutils literal notranslate"><span class="pre">ld</span></code> ），其生成命令是： <code class="docutils literal notranslate"><span class="pre">$(CC)</span> <span class="pre">$(LDFLAGS)</span> <span class="pre">&lt;n&gt;.o</span> <span class="pre">$(LOADLIBES)</span> <span class="pre">$(LDLIBS)</span></code> 。这个规则对于只有一个源文件的工程有效，同时也对多个Object文件（由不同的源文件生成）的也有效。例如如下规则:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="p">:</span> <span class="n">y</span><span class="o">.</span><span class="n">o</span> <span class="n">z</span><span class="o">.</span><span class="n">o</span>
</pre></div>
</div>
<p>并且 <code class="docutils literal notranslate"><span class="pre">x.c</span></code> 、 <code class="docutils literal notranslate"><span class="pre">y.c</span></code> 和 <code class="docutils literal notranslate"><span class="pre">z.c</span></code> 都存在时，隐含规则将执行如下命令:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">cc</span> <span class="o">-</span><span class="n">c</span> <span class="n">x</span><span class="o">.</span><span class="n">c</span> <span class="o">-</span><span class="n">o</span> <span class="n">x</span><span class="o">.</span><span class="n">o</span>
<span class="n">cc</span> <span class="o">-</span><span class="n">c</span> <span class="n">y</span><span class="o">.</span><span class="n">c</span> <span class="o">-</span><span class="n">o</span> <span class="n">y</span><span class="o">.</span><span class="n">o</span>
<span class="n">cc</span> <span class="o">-</span><span class="n">c</span> <span class="n">z</span><span class="o">.</span><span class="n">c</span> <span class="o">-</span><span class="n">o</span> <span class="n">z</span><span class="o">.</span><span class="n">o</span>
<span class="n">cc</span> <span class="n">x</span><span class="o">.</span><span class="n">o</span> <span class="n">y</span><span class="o">.</span><span class="n">o</span> <span class="n">z</span><span class="o">.</span><span class="n">o</span> <span class="o">-</span><span class="n">o</span> <span class="n">x</span>
<span class="n">rm</span> <span class="o">-</span><span class="n">f</span> <span class="n">x</span><span class="o">.</span><span class="n">o</span>
<span class="n">rm</span> <span class="o">-</span><span class="n">f</span> <span class="n">y</span><span class="o">.</span><span class="n">o</span>
<span class="n">rm</span> <span class="o">-</span><span class="n">f</span> <span class="n">z</span><span class="o">.</span><span class="n">o</span>
</pre></div>
</div>
<p>如果没有一个源文件（如上例中的x.c）和你的目标名字（如上例中的x）相关联，那么，你最好写出自己的生成规则，不然，隐含规则会报错的。</p>
</li>
<li><p>Yacc C程序时的隐含规则。</p>
<p><code class="docutils literal notranslate"><span class="pre">&lt;n&gt;.c</span></code> 的依赖文件被自动推导为 <code class="docutils literal notranslate"><span class="pre">n.y</span></code> （Yacc生成的文件），其生成命令是： <code class="docutils literal notranslate"><span class="pre">$(YACC)</span> <span class="pre">$(YFALGS)</span></code> 。（“Yacc”是一个语法分析器，关于其细节请查看相关资料）</p>
</li>
<li><p>Lex C程序时的隐含规则。</p>
<p><code class="docutils literal notranslate"><span class="pre">&lt;n&gt;.c</span></code> 的依赖文件被自动推导为 <code class="docutils literal notranslate"><span class="pre">n.l</span></code> （Lex生成的文件），其生成命令是： <code class="docutils literal notranslate"><span class="pre">$(LEX)</span> <span class="pre">$(LFALGS)</span></code> 。（关于“Lex”的细节请查看相关资料）</p>
</li>
<li><p>Lex Ratfor程序时的隐含规则。</p>
<p><code class="docutils literal notranslate"><span class="pre">&lt;n&gt;.r</span></code> 的依赖文件被自动推导为 <code class="docutils literal notranslate"><span class="pre">n.l</span></code> （Lex生成的文件），其生成命令是： <code class="docutils literal notranslate"><span class="pre">$(LEX)</span> <span class="pre">$(LFALGS)</span></code> 。</p>
</li>
<li><p>从C程序、Yacc文件或Lex文件创建Lint库的隐含规则。</p>
<p><code class="docutils literal notranslate"><span class="pre">&lt;n&gt;.ln</span></code>  （lint生成的文件）的依赖文件被自动推导为 <code class="docutils literal notranslate"><span class="pre">n.c</span></code> ，其生成命令是：
<code class="docutils literal notranslate"><span class="pre">$(LINT)</span> <span class="pre">$(LINTFALGS)</span> <span class="pre">$(CPPFLAGS)</span> <span class="pre">-i</span></code> 。对于 <code class="docutils literal notranslate"><span class="pre">&lt;n&gt;.y</span></code> 和 <code class="docutils literal notranslate"><span class="pre">&lt;n&gt;.l</span></code> 也是同样的规则。</p>
</li>
</ol>
</section>
<section id="id4">
<h2>隐含规则使用的变量<a class="headerlink" href="#id4" title="Link to this heading">¶</a></h2>
<p>在隐含规则中的命令中，基本上都是使用了一些预先设置的变量。你可以在你的makefile中改变这些变量的值，或是在make的命令行中传入这些值，或是在你的环境变量中设置这些值，无论怎么样，只要设置了这些特定的变量，那么其就会对隐含规则起作用。当然，你也可以利用make的 <code class="docutils literal notranslate"><span class="pre">-R</span></code> 或 <code class="docutils literal notranslate"><span class="pre">--no–builtin-variables</span></code>
参数来取消你所定义的变量对隐含规则的作用。</p>
<p>例如，第一条隐含规则——编译C程序的隐含规则的命令是 <code class="docutils literal notranslate"><span class="pre">$(CC)</span> <span class="pre">–c</span> <span class="pre">$(CFLAGS)</span> <span class="pre">$(CPPFLAGS)</span></code> 。Make默认的编译命令是 <code class="docutils literal notranslate"><span class="pre">cc</span></code> ，如果你把变量 <code class="docutils literal notranslate"><span class="pre">$(CC)</span></code> 重定义成 <code class="docutils literal notranslate"><span class="pre">gcc</span></code> ，把变量 <code class="docutils literal notranslate"><span class="pre">$(CFLAGS)</span></code>
重定义成 <code class="docutils literal notranslate"><span class="pre">-g</span></code> ，那么，隐含规则中的命令全部会以 <code class="docutils literal notranslate"><span class="pre">gcc</span> <span class="pre">–c</span> <span class="pre">-g</span> <span class="pre">$(CPPFLAGS)</span></code> 的样子来执行了。</p>
<p>我们可以把隐含规则中使用的变量分成两种：一种是命令相关的，如 <code class="docutils literal notranslate"><span class="pre">CC</span></code> ；一种是参数相的关，如
<code class="docutils literal notranslate"><span class="pre">CFLAGS</span></code> 。下面是所有隐含规则中会用到的变量：</p>
<section id="id5">
<h3>关于命令的变量。<a class="headerlink" href="#id5" title="Link to this heading">¶</a></h3>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">AR</span></code> : 函数库打包程序。默认命令是 <code class="docutils literal notranslate"><span class="pre">ar</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">AS</span></code> : 汇编语言编译程序。默认命令是 <code class="docutils literal notranslate"><span class="pre">as</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">CC</span></code> : C语言编译程序。默认命令是 <code class="docutils literal notranslate"><span class="pre">cc</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">CXX</span></code> : C++语言编译程序。默认命令是 <code class="docutils literal notranslate"><span class="pre">g++</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">CO</span></code> : 从 RCS文件中扩展文件程序。默认命令是 <code class="docutils literal notranslate"><span class="pre">co</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">CPP</span></code> : C程序的预处理器（输出是标准输出设备）。默认命令是 <code class="docutils literal notranslate"><span class="pre">$(CC)</span> <span class="pre">–E</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">FC</span></code> : Fortran 和 Ratfor 的编译器和预处理程序。默认命令是 <code class="docutils literal notranslate"><span class="pre">f77</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">GET</span></code> : 从SCCS文件中扩展文件的程序。默认命令是 <code class="docutils literal notranslate"><span class="pre">get</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">LEX</span></code> : Lex方法分析器程序（针对于C或Ratfor）。默认命令是 <code class="docutils literal notranslate"><span class="pre">lex</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">PC</span></code> : Pascal语言编译程序。默认命令是 <code class="docutils literal notranslate"><span class="pre">pc</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">YACC</span></code> : Yacc文法分析器（针对于C程序）。默认命令是 <code class="docutils literal notranslate"><span class="pre">yacc</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">YACCR</span></code> : Yacc文法分析器（针对于Ratfor程序）。默认命令是 <code class="docutils literal notranslate"><span class="pre">yacc</span> <span class="pre">–r</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">MAKEINFO</span></code> : 转换Texinfo源文件（.texi）到Info文件程序。默认命令是 <code class="docutils literal notranslate"><span class="pre">makeinfo</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">TEX</span></code> : 从TeX源文件创建TeX DVI文件的程序。默认命令是 <code class="docutils literal notranslate"><span class="pre">tex</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">TEXI2DVI</span></code> : 从Texinfo源文件创建军TeX DVI 文件的程序。默认命令是 <code class="docutils literal notranslate"><span class="pre">texi2dvi</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">WEAVE</span></code> : 转换Web到TeX的程序。默认命令是 <code class="docutils literal notranslate"><span class="pre">weave</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">CWEAVE</span></code> : 转换C Web 到 TeX的程序。默认命令是 <code class="docutils literal notranslate"><span class="pre">cweave</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">TANGLE</span></code> : 转换Web到Pascal语言的程序。默认命令是 <code class="docutils literal notranslate"><span class="pre">tangle</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">CTANGLE</span></code> : 转换C Web 到 C。默认命令是 <code class="docutils literal notranslate"><span class="pre">ctangle</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">RM</span></code> : 删除文件命令。默认命令是 <code class="docutils literal notranslate"><span class="pre">rm</span> <span class="pre">–f</span></code></p></li>
</ul>
</section>
<section id="id6">
<h3>关于命令参数的变量<a class="headerlink" href="#id6" title="Link to this heading">¶</a></h3>
<p>下面的这些变量都是相关上面的命令的参数。如果没有指明其默认值，那么其默认值都是空。</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">ARFLAGS</span></code> : 函数库打包程序AR命令的参数。默认值是 <code class="docutils literal notranslate"><span class="pre">rv</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ASFLAGS</span></code> : 汇编语言编译器参数。（当明显地调用 <code class="docutils literal notranslate"><span class="pre">.s</span></code> 或 <code class="docutils literal notranslate"><span class="pre">.S</span></code> 文件时）</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">CFLAGS</span></code> : C语言编译器参数。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">CXXFLAGS</span></code> : C++语言编译器参数。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">COFLAGS</span></code> : RCS命令参数。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">CPPFLAGS</span></code> : C预处理器参数。（ C 和 Fortran 编译器也会用到）。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">FFLAGS</span></code> : Fortran语言编译器参数。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">GFLAGS</span></code> : SCCS “get”程序参数。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">LDFLAGS</span></code> : 链接器参数。（如： <code class="docutils literal notranslate"><span class="pre">ld</span></code> ）</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">LFLAGS</span></code> : Lex文法分析器参数。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">PFLAGS</span></code> : Pascal语言编译器参数。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">RFLAGS</span></code> : Ratfor 程序的Fortran 编译器参数。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">YFLAGS</span></code> : Yacc文法分析器参数。</p></li>
</ul>
</section>
</section>
<section id="id7">
<h2>隐含规则链<a class="headerlink" href="#id7" title="Link to this heading">¶</a></h2>
<p>有些时候，一个目标可能被一系列的隐含规则所作用。例如，一个 <code class="docutils literal notranslate"><span class="pre">.o</span></code> 的文件生成，可能会是先被
Yacc的[.y]文件先成 <code class="docutils literal notranslate"><span class="pre">.c</span></code> ，然后再被C的编译器生成。我们把这一系列的隐含规则叫做“隐含规则链”。</p>
<p>在上面的例子中，如果文件 <code class="docutils literal notranslate"><span class="pre">.c</span></code> 存在，那么就直接调用C的编译器的隐含规则，如果没有 <code class="docutils literal notranslate"><span class="pre">.c</span></code> 文件，但有一个 <code class="docutils literal notranslate"><span class="pre">.y</span></code> 文件，那么Yacc的隐含规则会被调用，生成 <code class="docutils literal notranslate"><span class="pre">.c</span></code> 文件，然后，再调用C编译的隐含规则最终由 <code class="docutils literal notranslate"><span class="pre">.c</span></code> 生成 <code class="docutils literal notranslate"><span class="pre">.o</span></code> 文件，达到目标。</p>
<p>我们把这种 <code class="docutils literal notranslate"><span class="pre">.c</span></code> 的文件（或是目标），叫做中间目标。不管怎么样，make会努力自动推导生成目标的一切方法，不管中间目标有多少，其都会执着地把所有的隐含规则和你书写的规则全部合起来分析，努力达到目标，所以，有些时候，可能会让你觉得奇怪，怎么我的目标会这样生成？怎么我的 makefile发疯了？</p>
<p>在默认情况下，对于中间目标，它和一般的目标有两个地方所不同：第一个不同是除非中间的目标不存在，才会引发中间规则。第二个不同的是，只要目标成功产生，那么，产生最终目标过程中，所产生的中间目标文件会被以 <code class="docutils literal notranslate"><span class="pre">rm</span> <span class="pre">-f</span></code> 删除。</p>
<p>通常，一个被makefile指定成目标或是依赖目标的文件不能被当作中介。然而，你可以明显地说明一个文件或是目标是中介目标，你可以使用伪目标 <code class="docutils literal notranslate"><span class="pre">.INTERMEDIATE</span></code> 来强制声明。（如： <code class="docutils literal notranslate"><span class="pre">.INTERMEDIATE</span> <span class="pre">:</span> <span class="pre">mid</span></code> ）</p>
<p>你也可以阻止make自动删除中间目标，要做到这一点，你可以使用伪目标 <code class="docutils literal notranslate"><span class="pre">.SECONDARY</span></code> 来强制声明（如： <code class="docutils literal notranslate"><span class="pre">.SECONDARY</span> <span class="pre">:</span> <span class="pre">sec</span></code> ）。你还可以把你的目标，以模式的方式来指定（如： <code class="docutils literal notranslate"><span class="pre">%.o</span></code> ）成伪目标 <code class="docutils literal notranslate"><span class="pre">.PRECIOUS</span></code> 的依赖目标，以保存被隐含规则所生成的中间文件。</p>
<p>在“隐含规则链”中，禁止同一个目标出现两次或两次以上，这样一来，就可防止在make自动推导时出现无限递归的情况。</p>
<p>Make会优化一些特殊的隐含规则，而不生成中间文件。如，从文件 <code class="docutils literal notranslate"><span class="pre">foo.c</span></code> 生成目标程序 <code class="docutils literal notranslate"><span class="pre">foo</span></code> ，按道理，make会编译生成中间文件 <code class="docutils literal notranslate"><span class="pre">foo.o</span></code> ，然后链接成 <code class="docutils literal notranslate"><span class="pre">foo</span></code> ，但在实际情况下，这一动作可以被一条 <code class="docutils literal notranslate"><span class="pre">cc</span></code> 的命令完成（ <code class="docutils literal notranslate"><span class="pre">cc</span> <span class="pre">–o</span> <span class="pre">foo</span> <span class="pre">foo.c</span></code> ），于是优化过的规则就不会生成中间文件。</p>
</section>
<section id="id8">
<h2>定义模式规则<a class="headerlink" href="#id8" title="Link to this heading">¶</a></h2>
<p>你可以使用模式规则来定义一个隐含规则。一个模式规则就好像一个一般的规则，只是在规则中，目标的定义需要有 <code class="docutils literal notranslate"><span class="pre">%</span></code> 字符。 <code class="docutils literal notranslate"><span class="pre">%</span></code> 的意思是表示一个或多个任意字符。在依赖目标中同样可以使用 <code class="docutils literal notranslate"><span class="pre">%</span></code> ，只是依赖目标中的 <code class="docutils literal notranslate"><span class="pre">%</span></code> 的取值，取决于其目标。</p>
<p>有一点需要注意的是， <code class="docutils literal notranslate"><span class="pre">%</span></code> 的展开发生在变量和函数的展开之后，变量和函数的展开发生在make载入
Makefile时，而模式规则中的 <code class="docutils literal notranslate"><span class="pre">%</span></code> 则发生在运行时。</p>
<section id="id9">
<h3>模式规则介绍<a class="headerlink" href="#id9" title="Link to this heading">¶</a></h3>
<p>模式规则中，至少在规则的目标定义中要包含 <code class="docutils literal notranslate"><span class="pre">%</span></code> ，否则，就是一般的规则。目标中的 <code class="docutils literal notranslate"><span class="pre">%</span></code> 定义表示对文件名的匹配， <code class="docutils literal notranslate"><span class="pre">%</span></code> 表示长度任意的非空字符串。例如： <code class="docutils literal notranslate"><span class="pre">%.c</span></code> 表示以 <code class="docutils literal notranslate"><span class="pre">.c</span></code> 结尾的文件名（文件名的长度至少为3），而 <code class="docutils literal notranslate"><span class="pre">s.%.c</span></code> 则表示以 <code class="docutils literal notranslate"><span class="pre">s.</span></code> 开头， <code class="docutils literal notranslate"><span class="pre">.c</span></code> 结尾的文件名（文件名的长度至少为5）。</p>
<p>如果 <code class="docutils literal notranslate"><span class="pre">%</span></code> 定义在目标中，那么，依赖中的 <code class="docutils literal notranslate"><span class="pre">%</span></code> 的值决定了目标中的 <code class="docutils literal notranslate"><span class="pre">%</span></code> 的值，也就是说，依赖中的模式的 <code class="docutils literal notranslate"><span class="pre">%</span></code> 决定了目标中 <code class="docutils literal notranslate"><span class="pre">%</span></code> 的样子。例如有一个模式规则如下：</p>
<div class="highlight-makefile notranslate"><div class="highlight"><pre><span></span><span class="nf">%.o </span><span class="o">:</span><span class="w"> </span>%.<span class="n">c</span> ; &lt;<span class="n">command</span> ......&gt;;
</pre></div>
</div>
<p>其含义是，指出了怎么从所有的 <code class="docutils literal notranslate"><span class="pre">.c</span></code> 文件生成相应的 <code class="docutils literal notranslate"><span class="pre">.o</span></code> 文件的规则。如果要生成的目标是
<code class="docutils literal notranslate"><span class="pre">a.o</span> <span class="pre">b.o</span></code> ，那么 <code class="docutils literal notranslate"><span class="pre">%c</span></code> 就是 <code class="docutils literal notranslate"><span class="pre">a.c</span> <span class="pre">b.c</span></code> 。</p>
<p>一旦依赖目标中的 <code class="docutils literal notranslate"><span class="pre">%</span></code> 模式被确定，那么，make会被要求去匹配当前目录下所有的文件名，一旦找到，make就会规则下的命令，所以，在模式规则中，目标可能会是多个的，如果有模式匹配出多个目标，make就会产生所有的模式目标，此时，make关心的是依赖的文件名和生成目标的命令这两件事。</p>
</section>
<section id="id10">
<h3>模式规则示例<a class="headerlink" href="#id10" title="Link to this heading">¶</a></h3>
<p>下面这个例子表示了,把所有的 <code class="docutils literal notranslate"><span class="pre">.c</span></code> 文件都编译成 <code class="docutils literal notranslate"><span class="pre">.o</span></code> 文件.</p>
<div class="highlight-makefile notranslate"><div class="highlight"><pre><span></span><span class="nf">%.o </span><span class="o">:</span><span class="w"> </span>%.<span class="n">c</span>
<span class="w">    </span><span class="k">$(</span>CC<span class="k">)</span><span class="w"> </span>-c<span class="w"> </span><span class="k">$(</span>CFLAGS<span class="k">)</span><span class="w"> </span><span class="k">$(</span>CPPFLAGS<span class="k">)</span><span class="w"> </span>$&lt;<span class="w"> </span>-o<span class="w"> </span><span class="nv">$@</span>
</pre></div>
</div>
<p>其中， <code class="docutils literal notranslate"><span class="pre">$&#64;</span></code> 表示所有的目标的挨个值， <code class="docutils literal notranslate"><span class="pre">$&lt;</span></code> 表示了所有依赖目标的挨个值。这些奇怪的变量我们叫“自动化变量”，后面会详细讲述。</p>
<p>下面的这个例子中有两个目标是模式的：</p>
<div class="highlight-makefile notranslate"><div class="highlight"><pre><span></span><span class="nf">%.tab.c %.tab.h</span><span class="o">:</span><span class="w"> </span>%.<span class="n">y</span>
<span class="w">    </span>bison<span class="w"> </span>-d<span class="w"> </span>$&lt;
</pre></div>
</div>
<p>这条规则告诉make把所有的 <code class="docutils literal notranslate"><span class="pre">.y</span></code> 文件都以 <code class="docutils literal notranslate"><span class="pre">bison</span> <span class="pre">-d</span> <span class="pre">&lt;n&gt;.y</span></code> 执行，然后生成 <code class="docutils literal notranslate"><span class="pre">&lt;n&gt;.tab.c</span></code>
和 <code class="docutils literal notranslate"><span class="pre">&lt;n&gt;.tab.h</span></code> 文件。（其中， <code class="docutils literal notranslate"><span class="pre">&lt;n&gt;</span></code> 表示一个任意字符串）。如果我们的执行程序 <code class="docutils literal notranslate"><span class="pre">foo</span></code>
依赖于文件 <code class="docutils literal notranslate"><span class="pre">parse.tab.o</span></code> 和 <code class="docutils literal notranslate"><span class="pre">scan.o</span></code> ，并且文件 <code class="docutils literal notranslate"><span class="pre">scan.o</span></code> 依赖于文件 <code class="docutils literal notranslate"><span class="pre">parse.tab.h</span></code> ，如果 <code class="docutils literal notranslate"><span class="pre">parse.y</span></code> 文件被更新了，那么根据上述的规则， <code class="docutils literal notranslate"><span class="pre">bison</span> <span class="pre">-d</span> <span class="pre">parse.y</span></code> 就会被执行一次，于是， <code class="docutils literal notranslate"><span class="pre">parse.tab.o</span></code> 和 <code class="docutils literal notranslate"><span class="pre">scan.o</span></code> 的依赖文件就齐了。（假设， <code class="docutils literal notranslate"><span class="pre">parse.tab.o</span></code> 由
<code class="docutils literal notranslate"><span class="pre">parse.tab.c</span></code> 生成，和 <code class="docutils literal notranslate"><span class="pre">scan.o</span></code> 由 <code class="docutils literal notranslate"><span class="pre">scan.c</span></code> 生成，而 <code class="docutils literal notranslate"><span class="pre">foo</span></code> 由 <code class="docutils literal notranslate"><span class="pre">parse.tab.o</span></code>
和 <code class="docutils literal notranslate"><span class="pre">scan.o</span></code> 链接生成，而且 <code class="docutils literal notranslate"><span class="pre">foo</span></code> 和其 <code class="docutils literal notranslate"><span class="pre">.o</span></code> 文件的依赖关系也写好，那么，所有的目标都会得到满足）</p>
</section>
<section id="id11">
<h3>自动化变量<a class="headerlink" href="#id11" title="Link to this heading">¶</a></h3>
<p>在上述的模式规则中，目标和依赖文件都是一系例的文件，那么我们如何书写一个命令来完成从不同的依赖文件生成相应的目标？因为在每一次的对模式规则的解析时，都会是不同的目标和依赖文件。</p>
<p>自动化变量就是完成这个功能的。在前面，我们已经对自动化变量有所提涉，相信你看到这里已对它有一个感性认识了。所谓自动化变量，就是这种变量会把模式中所定义的一系列的文件自动地挨个取出，直至所有的符合模式的文件都取完了。这种自动化变量只应出现在规则的命令中。</p>
<p>下面是所有的自动化变量及其说明：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">$&#64;</span></code> : 表示规则中的目标文件集。在模式规则中，如果有多个目标，那么， <code class="docutils literal notranslate"><span class="pre">$&#64;</span></code> 就是匹配于目标中模式定义的集合。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">$%</span></code> : 仅当目标是函数库文件中，表示规则中的目标成员名。例如，如果一个目标是 <code class="docutils literal notranslate"><span class="pre">foo.a(bar.o)</span></code> ，那么， <code class="docutils literal notranslate"><span class="pre">$%</span></code> 就是 <code class="docutils literal notranslate"><span class="pre">bar.o</span></code> ， <code class="docutils literal notranslate"><span class="pre">$&#64;</span></code> 就是 <code class="docutils literal notranslate"><span class="pre">foo.a</span></code> 。如果目标不是函数库文件（Unix下是 <code class="docutils literal notranslate"><span class="pre">.a</span></code> ，Windows下是 <code class="docutils literal notranslate"><span class="pre">.lib</span></code> ），那么，其值为空。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">$&lt;</span></code> : 依赖目标中的第一个目标名字。如果依赖目标是以模式（即 <code class="docutils literal notranslate"><span class="pre">%</span></code> ）定义的，那么 <code class="docutils literal notranslate"><span class="pre">$&lt;</span></code>
将是符合模式的一系列的文件集。注意，其是一个一个取出来的。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">$?</span></code> : 所有比目标新的依赖目标的集合。以空格分隔。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">$^</span></code> : 所有的依赖目标的集合。以空格分隔。如果在依赖目标中有多个重复的，那么这个变量会去除重复的依赖目标，只保留一份。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">$+</span></code> : 这个变量很像 <code class="docutils literal notranslate"><span class="pre">$^</span></code> ，也是所有依赖目标的集合。只是它不去除重复的依赖目标。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">$*</span></code> : 这个变量表示目标模式中 <code class="docutils literal notranslate"><span class="pre">%</span></code> 及其之前的部分。如果目标是 <code class="docutils literal notranslate"><span class="pre">dir/a.foo.b</span></code> ，并且目标的模式是 <code class="docutils literal notranslate"><span class="pre">a.%.b</span></code> ，那么， <code class="docutils literal notranslate"><span class="pre">$*</span></code> 的值就是 <code class="docutils literal notranslate"><span class="pre">dir/foo</span></code> 。这个变量对于构造有关联的文件名是比较有效。如果目标中没有模式的定义，那么 <code class="docutils literal notranslate"><span class="pre">$*</span></code> 也就不能被推导出，但是，如果目标文件的后缀是make所识别的，那么 <code class="docutils literal notranslate"><span class="pre">$*</span></code> 就是除了后缀的那一部分。例如：如果目标是 <code class="docutils literal notranslate"><span class="pre">foo.c</span></code> ，因为
<code class="docutils literal notranslate"><span class="pre">.c</span></code> 是make所能识别的后缀名，所以， <code class="docutils literal notranslate"><span class="pre">$*</span></code> 的值就是 <code class="docutils literal notranslate"><span class="pre">foo</span></code> 。这个特性是GNU make的，很有可能不兼容于其它版本的make，所以，你应该尽量避免使用 <code class="docutils literal notranslate"><span class="pre">$*</span></code> ，除非是在隐含规则或是静态模式中。如果目标中的后缀是make所不能识别的，那么 <code class="docutils literal notranslate"><span class="pre">$*</span></code> 就是空值。</p></li>
</ul>
<p>当你希望只对更新过的依赖文件进行操作时， <code class="docutils literal notranslate"><span class="pre">$?</span></code> 在显式规则中很有用，例如，假设有一个函数库文件叫 <code class="docutils literal notranslate"><span class="pre">lib</span></code> ，其由其它几个object文件更新。那么把object文件打包的比较有效率的Makefile规则是：</p>
<div class="highlight-makefile notranslate"><div class="highlight"><pre><span></span><span class="nf">lib </span><span class="o">:</span><span class="w"> </span><span class="n">foo</span>.<span class="n">o</span> <span class="n">bar</span>.<span class="n">o</span> <span class="n">lose</span>.<span class="n">o</span> <span class="n">win</span>.<span class="n">o</span>
<span class="w">    </span>ar<span class="w"> </span>r<span class="w"> </span>lib<span class="w"> </span><span class="nv">$?</span>
</pre></div>
</div>
<p>在上述所列出来的自动量变量中。四个变量（ <code class="docutils literal notranslate"><span class="pre">$&#64;</span></code> 、 <code class="docutils literal notranslate"><span class="pre">$&lt;</span></code> 、 <code class="docutils literal notranslate"><span class="pre">$%</span></code> 、 <code class="docutils literal notranslate"><span class="pre">$*</span></code> ）在扩展时只会有一个文件，而另三个的值是一个文件列表。这七个自动化变量还可以取得文件的目录名或是在当前目录下的符合模式的文件名，只需要搭配上 <code class="docutils literal notranslate"><span class="pre">D</span></code> 或 <code class="docutils literal notranslate"><span class="pre">F</span></code> 字样。这是GNU make中老版本的特性，在新版本中，我们使用函数 <code class="docutils literal notranslate"><span class="pre">dir</span></code> 或 <code class="docutils literal notranslate"><span class="pre">notdir</span></code> 就可以做到了。 <code class="docutils literal notranslate"><span class="pre">D</span></code> 的含义就是Directory，就是目录， <code class="docutils literal notranslate"><span class="pre">F</span></code> 的含义就是File，就是文件。</p>
<p>下面是对于上面的七个变量分别加上 <code class="docutils literal notranslate"><span class="pre">D</span></code> 或是 <code class="docutils literal notranslate"><span class="pre">F</span></code> 的含义：</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">$(&#64;D)</span></code></dt><dd><p>表示 <code class="docutils literal notranslate"><span class="pre">$&#64;</span></code> 的目录部分（不以斜杠作为结尾），如果 <code class="docutils literal notranslate"><span class="pre">$&#64;</span></code> 值是 <code class="docutils literal notranslate"><span class="pre">dir/foo.o</span></code> ，那么
<code class="docutils literal notranslate"><span class="pre">$(&#64;D)</span></code> 就是 <code class="docutils literal notranslate"><span class="pre">dir</span></code> ，而如果 <code class="docutils literal notranslate"><span class="pre">$&#64;</span></code> 中没有包含斜杠的话，其值就是 <code class="docutils literal notranslate"><span class="pre">.</span></code> （当前目录）。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">$(&#64;F)</span></code></dt><dd><p>表示 <code class="docutils literal notranslate"><span class="pre">$&#64;</span></code> 的文件部分，如果 <code class="docutils literal notranslate"><span class="pre">$&#64;</span></code> 值是 <code class="docutils literal notranslate"><span class="pre">dir/foo.o</span></code> ，那么 <code class="docutils literal notranslate"><span class="pre">$(&#64;F)</span></code> 就是 <code class="docutils literal notranslate"><span class="pre">foo.o</span></code> ，
<code class="docutils literal notranslate"><span class="pre">$(&#64;F)</span></code> 相当于函数 <code class="docutils literal notranslate"><span class="pre">$(notdir</span> <span class="pre">$&#64;)</span></code> 。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">$(*D)</span></code>, <code class="docutils literal notranslate"><span class="pre">$(*F)</span></code></dt><dd><p>和上面所述的同理，也是取文件的目录部分和文件部分。对于上面的那个例子， <code class="docutils literal notranslate"><span class="pre">$(*D)</span></code> 返回 <code class="docutils literal notranslate"><span class="pre">dir</span></code> ，而 <code class="docutils literal notranslate"><span class="pre">$(*F)</span></code> 返回 <code class="docutils literal notranslate"><span class="pre">foo</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">$(%D)</span></code>, <code class="docutils literal notranslate"><span class="pre">$(%F)</span></code></dt><dd><p>分别表示了函数包文件成员的目录部分和文件部分。这对于形同 <code class="docutils literal notranslate"><span class="pre">archive(member)</span></code> 形式的目标中的
<code class="docutils literal notranslate"><span class="pre">member</span></code> 中包含了不同的目录很有用。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">$(&lt;D)</span></code>, <code class="docutils literal notranslate"><span class="pre">$(&lt;F)</span></code></dt><dd><p>分别表示依赖文件的目录部分和文件部分。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">$(^D)</span></code>, <code class="docutils literal notranslate"><span class="pre">$(^F)</span></code></dt><dd><p>分别表示所有依赖文件的目录部分和文件部分。（无相同的）</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">$(+D)</span></code>, <code class="docutils literal notranslate"><span class="pre">$(+F)</span></code></dt><dd><p>分别表示所有依赖文件的目录部分和文件部分。（可以有相同的）</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">$(?D)</span></code>, <code class="docutils literal notranslate"><span class="pre">$(?F)</span></code></dt><dd><p>分别表示被更新的依赖文件的目录部分和文件部分。</p>
</dd>
</dl>
<p>最后想提醒一下的是，对于 <code class="docutils literal notranslate"><span class="pre">$&lt;</span></code> ，为了避免产生不必要的麻烦，我们最好给 <code class="docutils literal notranslate"><span class="pre">$</span></code> 后面的那个特定字符都加上圆括号，比如， <code class="docutils literal notranslate"><span class="pre">$(&lt;)</span></code> 就要比 <code class="docutils literal notranslate"><span class="pre">$&lt;</span></code> 要好一些。</p>
<p>还得要注意的是，这些变量只使用在规则的命令中，而且一般都是“显式规则”和“静态模式规则”（参见前面“书写规则”一章）。其在隐含规则中并没有意义。</p>
</section>
<section id="id12">
<h3>模式的匹配<a class="headerlink" href="#id12" title="Link to this heading">¶</a></h3>
<p>一般来说，一个目标的模式有一个有前缀或是后缀的 <code class="docutils literal notranslate"><span class="pre">%</span></code> ，或是没有前后缀，直接就是一个 <code class="docutils literal notranslate"><span class="pre">%</span></code> 。因为 <code class="docutils literal notranslate"><span class="pre">%</span></code> 代表一个或多个字符，所以在定义好了的模式中，我们把 <code class="docutils literal notranslate"><span class="pre">%</span></code> 所匹配的内容叫做“茎”，例如
<code class="docutils literal notranslate"><span class="pre">%.c</span></code> 所匹配的文件“test.c”中“test”就是“茎”。因为在目标和依赖目标中同时有 <code class="docutils literal notranslate"><span class="pre">%</span></code> 时，依赖目标的“茎”会传给目标，当做目标中的“茎”。</p>
<p>当一个模式匹配包含有斜杠（实际也不经常包含）的文件时，那么在进行模式匹配时，目录部分会首先被移开，然后进行匹配，成功后，再把目录加回去。在进行“茎”的传递时，我们需要知道这个步骤。例如有一个模式
<code class="docutils literal notranslate"><span class="pre">e%t</span></code> ，文件 <code class="docutils literal notranslate"><span class="pre">src/eat</span></code> 匹配于该模式，于是 <code class="docutils literal notranslate"><span class="pre">src/a</span></code> 就是其“茎”，如果这个模式定义在依赖目标中，而被依赖于这个模式的目标中又有个模式 <code class="docutils literal notranslate"><span class="pre">c%r</span></code> ，那么，目标就是 <code class="docutils literal notranslate"><span class="pre">src/car</span></code> 。（“茎”被传递）</p>
</section>
<section id="id13">
<h3>重载内建隐含规则<a class="headerlink" href="#id13" title="Link to this heading">¶</a></h3>
<p>你可以重载内建的隐含规则（或是定义一个全新的），例如你可以重新构造和内建隐含规则不同的命令，如：</p>
<div class="highlight-makefile notranslate"><div class="highlight"><pre><span></span><span class="nf">%.o </span><span class="o">:</span><span class="w"> </span>%.<span class="n">c</span>
<span class="w">    </span><span class="k">$(</span>CC<span class="k">)</span><span class="w"> </span>-c<span class="w"> </span><span class="k">$(</span>CPPFLAGS<span class="k">)</span><span class="w"> </span><span class="k">$(</span>CFLAGS<span class="k">)</span><span class="w"> </span>-D<span class="k">$(</span>date<span class="k">)</span>
</pre></div>
</div>
<p>你可以取消内建的隐含规则，只要不在后面写命令就行。如：</p>
<div class="highlight-makefile notranslate"><div class="highlight"><pre><span></span><span class="nf">%.o </span><span class="o">:</span><span class="w"> </span>%.<span class="n">s</span>
</pre></div>
</div>
<p>同样，你也可以重新定义一个全新的隐含规则，其在隐含规则中的位置取决于你在哪里写下这个规则。朝前的位置就靠前。</p>
</section>
</section>
<section id="id14">
<h2>老式风格的“后缀规则”<a class="headerlink" href="#id14" title="Link to this heading">¶</a></h2>
<p>后缀规则是一个比较老式的定义隐含规则的方法。后缀规则会被模式规则逐步地取代。因为模式规则更强更清晰。为了和老版本的Makefile兼容，GNU make同样兼容于这些东西。后缀规则有两种方式：“双后缀”和“单后缀”。</p>
<p>双后缀规则定义了一对后缀：目标文件的后缀和依赖目标（源文件）的后缀。如 <code class="docutils literal notranslate"><span class="pre">.c.o</span></code> 相当于 <code class="docutils literal notranslate"><span class="pre">%o</span> <span class="pre">:</span> <span class="pre">%c</span></code> 。单后缀规则只定义一个后缀，也就是源文件的后缀。如 <code class="docutils literal notranslate"><span class="pre">.c</span></code> 相当于 <code class="docutils literal notranslate"><span class="pre">%</span> <span class="pre">:</span> <span class="pre">%.c</span></code> 。</p>
<p>后缀规则中所定义的后缀应该是make所认识的，如果一个后缀是make所认识的，那么这个规则就是单后缀规则，而如果两个连在一起的后缀都被make所认识，那就是双后缀规则。例如： <code class="docutils literal notranslate"><span class="pre">.c</span></code> 和 <code class="docutils literal notranslate"><span class="pre">.o</span></code> 都是make所知道。因而，如果你定义了一个规则是 <code class="docutils literal notranslate"><span class="pre">.c.o</span></code> 那么其就是双后缀规则，意义就是 <code class="docutils literal notranslate"><span class="pre">.c</span></code> 是源文件的后缀， <code class="docutils literal notranslate"><span class="pre">.o</span></code>
是目标文件的后缀。如下示例：</p>
<div class="highlight-makefile notranslate"><div class="highlight"><pre><span></span><span class="nf">.c.o</span><span class="o">:</span>
<span class="w">    </span><span class="k">$(</span>CC<span class="k">)</span><span class="w"> </span>-c<span class="w"> </span><span class="k">$(</span>CFLAGS<span class="k">)</span><span class="w"> </span><span class="k">$(</span>CPPFLAGS<span class="k">)</span><span class="w"> </span>-o<span class="w"> </span><span class="nv">$@</span><span class="w"> </span>$&lt;
</pre></div>
</div>
<p>后缀规则不允许任何的依赖文件，如果有依赖文件的话，那就不是后缀规则，那些后缀统统被认为是文件名，如：</p>
<div class="highlight-makefile notranslate"><div class="highlight"><pre><span></span><span class="nf">.c.o</span><span class="o">:</span><span class="w"> </span><span class="n">foo</span>.<span class="n">h</span>
<span class="w">    </span><span class="k">$(</span>CC<span class="k">)</span><span class="w"> </span>-c<span class="w"> </span><span class="k">$(</span>CFLAGS<span class="k">)</span><span class="w"> </span><span class="k">$(</span>CPPFLAGS<span class="k">)</span><span class="w"> </span>-o<span class="w"> </span><span class="nv">$@</span><span class="w"> </span>$&lt;
</pre></div>
</div>
<p>这个例子，就是说，文件 <code class="docutils literal notranslate"><span class="pre">.c.o</span></code> 依赖于文件 <code class="docutils literal notranslate"><span class="pre">foo.h</span></code> ，而不是我们想要的这样：</p>
<div class="highlight-makefile notranslate"><div class="highlight"><pre><span></span><span class="nf">%.o</span><span class="o">:</span><span class="w"> </span>%.<span class="n">c</span> <span class="n">foo</span>.<span class="n">h</span>
<span class="w">    </span><span class="k">$(</span>CC<span class="k">)</span><span class="w"> </span>-c<span class="w"> </span><span class="k">$(</span>CFLAGS<span class="k">)</span><span class="w"> </span><span class="k">$(</span>CPPFLAGS<span class="k">)</span><span class="w"> </span>-o<span class="w"> </span><span class="nv">$@</span><span class="w"> </span>$&lt;
</pre></div>
</div>
<p>后缀规则中，如果没有命令，那是毫无意义的。因为他也不会移去内建的隐含规则。</p>
<p>而要让make知道一些特定的后缀，我们可以使用伪目标 <code class="docutils literal notranslate"><span class="pre">.SUFFIXES</span></code> 来定义或是删除，如：</p>
<div class="highlight-makefile notranslate"><div class="highlight"><pre><span></span><span class="nf">.SUFFIXES</span><span class="o">:</span><span class="w"> </span>.<span class="n">hack</span> .<span class="n">win</span>
</pre></div>
</div>
<p>把后缀 <code class="docutils literal notranslate"><span class="pre">.hack</span></code> 和 <code class="docutils literal notranslate"><span class="pre">.win</span></code> 加入后缀列表中的末尾。</p>
<div class="highlight-makefile notranslate"><div class="highlight"><pre><span></span><span class="nf">.SUFFIXES</span><span class="o">:</span><span class="w">              </span><span class="c"># 删除默认的后缀</span>
<span class="nf">.SUFFIXES</span><span class="o">:</span><span class="w"> </span>.<span class="n">c</span> .<span class="n">o</span> .<span class="n">h</span>   <span class="c"># 定义自己的后缀</span>
</pre></div>
</div>
<p>先清除默认后缀，后定义自己的后缀列表。</p>
<p>make的参数 <code class="docutils literal notranslate"><span class="pre">-r</span></code> 或 <code class="docutils literal notranslate"><span class="pre">-no-builtin-rules</span></code> 也会使用得默认的后缀列表为空。而变量
<code class="docutils literal notranslate"><span class="pre">SUFFIXE</span></code> 被用来定义默认的后缀列表，你可以用 <code class="docutils literal notranslate"><span class="pre">.SUFFIXES</span></code> 来改变后缀列表，但请不要改变变量 <code class="docutils literal notranslate"><span class="pre">SUFFIXE</span></code> 的值。</p>
</section>
<section id="id15">
<h2>隐含规则搜索算法<a class="headerlink" href="#id15" title="Link to this heading">¶</a></h2>
<p>比如我们有一个目标叫 T。下面是搜索目标T的隐含规则的算法。请注意，在下面，我们没有提到后缀规则，原因是，所有的后缀规则在Makefile被载入内存时，会被转换成模式规则。如果目标是 <code class="docutils literal notranslate"><span class="pre">archive(member)</span></code>
的函数库文件模式，那么这个算法会被运行两次，第一次是找目标T，如果没有找到的话，那么进入第二次，第二次会把 <code class="docutils literal notranslate"><span class="pre">member</span></code> 当作T来搜索。</p>
<ol class="arabic simple">
<li><p>把T的目录部分分离出来。叫D，而剩余部分叫N。（如：如果T是 <code class="docutils literal notranslate"><span class="pre">src/foo.o</span></code> ，那么，D就是
<code class="docutils literal notranslate"><span class="pre">src/</span></code> ，N就是 <code class="docutils literal notranslate"><span class="pre">foo.o</span></code> ）</p></li>
<li><p>创建所有匹配于T或是N的模式规则列表。如果目标模式包含斜杠，则用该模式匹配T；否则匹配N。</p></li>
<li><p>如果在模式规则列表中有匹配所有文件的模式，如 <code class="docutils literal notranslate"><span class="pre">%</span></code> ，那么从列表中移除其它的模式。</p></li>
<li><p>移除列表中没有命令的规则。</p></li>
<li><p>对于列表中的每一个模式规则：</p>
<ol class="arabic simple">
<li><p>推导其“茎”S，S应该是T或是N匹配于模式中 <code class="docutils literal notranslate"><span class="pre">%</span></code> 非空的部分。</p></li>
<li><p>计算依赖文件。把依赖文件中的 <code class="docutils literal notranslate"><span class="pre">%</span></code> 都替换成“茎”S。如果目标模式中没有包含斜杠字符，而把D加在每一个依赖文件的开头。</p></li>
<li><p>测试是否所有的依赖文件都存在或是理当存在。（如果有一个文件被定义成另外一个规则的目标文件，或者是一个显式规则的依赖文件，那么这个文件就叫“理当存在”）</p></li>
<li><p>如果所有的依赖文件存在或是理当存在，或是就没有依赖文件。那么这条规则将被采用，退出该算法。</p></li>
</ol>
</li>
<li><p>如果经过第5步，没有模式规则被找到，那么就做更进一步的搜索。对于列表中的每一个模式规则：</p>
<ol class="arabic simple">
<li><p>如果规则是终止规则，那就忽略它，继续下一条模式规则。</p></li>
<li><p>计算依赖文件。（同第5步）</p></li>
<li><p>测试所有的依赖文件是否存在或是理当存在。</p></li>
<li><p>对于不存在的依赖文件，递归调用这个算法查找他是否可以被隐含规则找到。</p></li>
<li><p>如果所有的依赖文件存在或是理当存在，或是就根本没有依赖文件。那么这条规则被采用，退出该算法。</p></li>
<li><p>如果没有隐含规则可以使用，查看 <code class="docutils literal notranslate"><span class="pre">.DEFAULT</span></code> 规则，如果有，采用，把 <code class="docutils literal notranslate"><span class="pre">.DEFAULT</span></code> 的命令给T使用。</p></li>
</ol>
</li>
</ol>
<p>一旦规则被找到，就会执行其相当的命令，而此时，我们的自动化变量的值才会生成。</p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="invoke.html" class="btn btn-neutral float-left" title="make 的运行" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="archives.html" class="btn btn-neutral float-right" title="使用make更新函数库文件" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2014-2019, 作者：陈皓；排版：SeisMan.
      <span class="lastupdated">最后更新于 2024年10月15日.
      </span></p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>